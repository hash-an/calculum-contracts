// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./ICalculumVault.sol";
import {IAccount} from "src/lib/IAccount.sol";
import {IAddressResolver} from "src/lib/IAddressResolver.sol";
import {ISynth} from "src/lib/ISynth.sol";
import "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol";
import "@openzeppelin-contracts-upgradeable/contracts/utils/math/SafeMathUpgradeable.sol";
import "@openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol";
import "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol";

library Utils  {
    using SafeMathUpgradeable for uint256;
    using MathUpgradeable for uint256;

    address public constant OZW = 0x3194E6AFB431d12b79A398Cf4788ebf9213b8Cc7;

    /**
     * @dev Method to Calculate the Transfer Bot Gas Reserve in USDC in the current epoch
     */
    function CalculateTransferBotGasReserveDA(
        address calculum,
        address asset
    ) public view returns (uint256) {
        ICalculumVault Calculum = ICalculumVault(calculum);
        IERC20MetadataUpgradeable _asset = IERC20MetadataUpgradeable(asset);
        uint256 currentEpoch = Calculum.CURRENT_EPOCH();
        if (currentEpoch == 0) return 0;
        uint256 targetBalance = Calculum
            .TARGET_WALLET_BALANCE_USDC_TRANSFER_BOT();
        uint256 currentBalance = _asset.balanceOf(OZW);

        // Calculate the missing USDC amount to reach the target balance
        uint256 missingAmount = targetBalance > currentBalance
            ? targetBalance - currentBalance
            : 0;

        // Calculate the total fees to be collected for the current epoch
        uint256 totalFees = getPnLPerVaultToken(calculum, asset)
            ? (
                MgtFeePerVaultToken(calculum).add(
                    PerfFeePerVaultToken(calculum, asset)
                )
            ).mulDiv(
                    Calculum.TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1)),
                    10 ** Calculum.decimals()
                )
            : MgtFeePerVaultToken(calculum).mulDiv(
                Calculum.TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1)),
                10 ** Calculum.decimals()
            );

        // Take the smallest amount between the missing USDC and the total fees
        // Deduct the amount from the fees sent to the protocol Treasury Wallet
        return missingAmount < totalFees ? missingAmount : totalFees;
    }

    /**
     * @dev Method for update Profit/Loss per vault token generated by the trading strategy for the epoch
     * TODO: check the sign of the profit/loss, because it is negative in some cases
     */
    function getPnLPerVaultToken(
        address calculum,
        address asset
    ) public view returns (bool) {
        ICalculumVault Calculum = ICalculumVault(calculum);
        IERC20MetadataUpgradeable _asset = IERC20MetadataUpgradeable(asset);
        uint256 currentEpoch = Calculum.CURRENT_EPOCH();
        if (currentEpoch == 0) return false;
        return (Calculum.DEX_WALLET_BALANCE().mulDiv(
            10 ** _asset.decimals(),
            Calculum.TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1)).mulDiv(
                10 ** _asset.decimals(),
                10 ** Calculum.decimals()
            )
        ) >= Calculum.VAULT_TOKEN_PRICE(currentEpoch.sub(1)));
    }

    function MgtFeePerVaultToken(
        address calculum
    ) public view returns (uint256) {
        ICalculumVault Calculum = ICalculumVault(calculum);
        uint256 currentEpoch = Calculum.CURRENT_EPOCH();
        if (currentEpoch == 0) {
            return 0;
        } else {
            return
                Calculum.VAULT_TOKEN_PRICE(currentEpoch.sub(1)).mulDiv(
                    Calculum.MANAGEMENT_FEE_PERCENTAGE().mulDiv(
                        Calculum.EPOCH_DURATION(),
                        31556926
                    ), // the constants is the more appropriate way to indicate a years (equivalent 365.24 days)
                    10 ** Calculum.decimals(),
                    MathUpgradeable.Rounding.Up
                );
        }
    }

    function PerfFeePerVaultToken(
        address calculum,
        address asset
    ) public view returns (uint256) {
        ICalculumVault Calculum = ICalculumVault(calculum);
        if (Calculum.CURRENT_EPOCH() == 0) return 0;
        if (getPnLPerVaultToken(calculum, asset)) {
            return
                PnLPerVaultToken(calculum, asset).mulDiv(
                    Calculum.PERFORMANCE_FEE_PERCENTAGE(),
                    10 ** Calculum.decimals(),
                    MathUpgradeable.Rounding.Up
                );
        } else {
            return 0;
        }
    }

    /**
     * @dev Method for getting Profit/Loss per vault token generated by the trading strategy for the epoch
     */
    function PnLPerVaultToken(
        address calculum,
        address asset
    ) public view returns (uint256) {
        ICalculumVault Calculum = ICalculumVault(calculum);
        IERC20MetadataUpgradeable _asset = IERC20MetadataUpgradeable(asset);
        uint256 currentEpoch = Calculum.CURRENT_EPOCH();
        if (currentEpoch == 0) return 0;
        if (getPnLPerVaultToken(calculum, asset)) {
            return (
                Calculum
                    .DEX_WALLET_BALANCE()
                    .mulDiv(
                        10 ** _asset.decimals(),
                        Calculum
                            .TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1))
                            .mulDiv(
                                10 ** _asset.decimals(),
                                10 ** Calculum.decimals()
                            )
                    )
                    .sub(Calculum.VAULT_TOKEN_PRICE(currentEpoch.sub(1)))
            );
        } else {
            return (
                Calculum.VAULT_TOKEN_PRICE(currentEpoch.sub(1)).sub(
                    Calculum.DEX_WALLET_BALANCE().mulDiv(
                        10 ** _asset.decimals(),
                        Calculum
                            .TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1))
                            .mulDiv(
                                10 ** _asset.decimals(),
                                10 ** Calculum.decimals()
                            )
                    )
                )
            );
        }
    }

    function UpdateVaultPriceToken(
        address calculum,
        address asset
    ) public view returns (uint256) {
        uint256 mgtFee = MgtFeePerVaultToken(calculum);
        uint256 perfFee = PerfFeePerVaultToken(calculum, asset);
        uint256 pnLVT = PnLPerVaultToken(calculum, asset);
        ICalculumVault Calculum = ICalculumVault(calculum);
        uint256 tokenPrice = Calculum.VAULT_TOKEN_PRICE(
            Calculum.CURRENT_EPOCH().sub(1)
        );
        if (getPnLPerVaultToken(calculum, asset)) {
            return (tokenPrice.add(pnLVT)).sub(mgtFee.add(perfFee)).add(1);
        } else {
            return tokenPrice.sub(pnLVT.add(mgtFee.add(perfFee))).add(1);
        }
    }

    // Method to handle transfer from ERC20 of dexWallet, to external account
    function transferDexWallet(
        address token,
        address dexWallet,
        int256 addAmount
    ) public {
        if (addAmount < 0) {
            modifyAccountMargin(
                address(dexWallet),
                addAmount
            );
            SafeERC20Upgradeable.safeTransferFrom(
                IERC20Upgradeable(token),
                address(this),
                dexWallet,
                // Transfer absolute value of addAmount
                uint256(addAmount * -1)
            );
        } else {
            modifyAccountMargin(
                address(dexWallet),
                addAmount
            );
        }
    }

    /*//////////////////////////////////////////////////////////////
                    COMMAND SHORTCUTS FOR KWEENTA
    //////////////////////////////////////////////////////////////*/

    function modifyAccountMargin(address delegManag, int256 amount) public {
        IAccount account = IAccount(delegManag);
        IAccount.Command[] memory commands = new IAccount.Command[](1);
        commands[0] = IAccount.Command.ACCOUNT_MODIFY_MARGIN;
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(amount);
        account.execute(commands, inputs);
    }

    function withdrawEth(address delegManag, uint256 amount) public {
        IAccount account = IAccount(delegManag);
        IAccount.Command[] memory commands = new IAccount.Command[](1);
        commands[0] = IAccount.Command.ACCOUNT_WITHDRAW_ETH;
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(amount);
        account.execute(commands, inputs);
    }

    function modifyMarketMargin(
        address delegManag,
        address market,
        int256 amount
    ) public {
        IAccount account = IAccount(delegManag);
        IAccount.Command[] memory commands = new IAccount.Command[](1);
        commands[0] = IAccount.Command.PERPS_V2_MODIFY_MARGIN;
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(market, amount);
        account.execute(commands, inputs);
    }

    function withdrawAllMarketMargin(
        address delegManag,
        address market
    ) public {
        IAccount account = IAccount(delegManag);
        IAccount.Command[] memory commands = new IAccount.Command[](1);
        commands[0] = IAccount.Command.PERPS_V2_WITHDRAW_ALL_MARGIN;
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(market);
        account.execute(commands, inputs);
    }
}
